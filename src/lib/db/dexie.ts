/**
 * IndexedDB Database using Dexie.js
 *
 * This module provides persistent storage for sales data and pre-computed aggregates.
 *
 * ## IMPORTANT: NO MIGRATION PATHS
 *
 * This database uses a "nuke and rebuild" strategy instead of migrations.
 * If the schema changes or old data is detected, the entire database is wiped.
 *
 * DO NOT add version() calls for schema migrations. If you need to change the schema:
 * 1. Update CURRENT_SCHEMA_VERSION constant
 * 2. The database will be automatically wiped on next startup
 *
 * This ensures there is exactly ONE valid data format at any time.
 *
 * ## Pre-computed Aggregates
 *
 * For large datasets, we pre-compute aggregates after data sync to enable instant
 * reads without iterating through all records. This is part of the three-tier
 * aggregation strategy:
 *
 * 1. **Real-time stores** (sales.ts): For small datasets with active filtering
 * 2. **Web Workers** (workers/): For large datasets during UI interaction
 * 3. **Pre-computed tables** (this file): For initial load and dashboard stats
 *
 * @see src/lib/workers/index.ts for the aggregation strategy documentation
 */

import Dexie, { type EntityTable } from 'dexie';
import type { SalesRecord, SyncMeta, Filters } from '$lib/services/types';

// ============================================================================
// Schema Version - INCREMENT THIS TO WIPE DATABASE ON NEXT STARTUP
// ============================================================================

/**
 * Current schema version. Increment this number to force a database wipe.
 *
 * Version history (for reference only - no migrations exist):
 * - v1: Initial schema with string-based unique keys
 *
 * DO NOT ADD MIGRATION LOGIC. Just increment and let the database wipe.
 */
const CURRENT_SCHEMA_VERSION = 1;

/**
 * Database name includes version to force fresh start on schema changes.
 * This is intentional - we do NOT support migrations.
 */
const DATABASE_NAME = `SteamSalesDB_v3_schema${CURRENT_SCHEMA_VERSION}`;

// ============================================================================
// Pre-computed aggregate types
// ============================================================================

export interface DailyAggregate {
  date: string;
  totalRevenue: number;
  totalUnits: number;
  recordCount: number;
}

export interface AppAggregate {
  appId: number;
  appName: string;
  totalRevenue: number;
  totalUnits: number;
  recordCount: number;
  firstSaleDate: string;
  lastSaleDate: string;
}

export interface CountryAggregate {
  countryCode: string;
  totalRevenue: number;
  totalUnits: number;
  recordCount: number;
}

export interface AggregatesMeta {
  key: string; // 'lastUpdated', 'totalRecords', 'schemaVersion', etc.
  value: string;
}

// ============================================================================
// Database Class - SINGLE SCHEMA VERSION ONLY
// ============================================================================

/**
 * Dexie database class with a single schema version.
 *
 * DO NOT ADD ADDITIONAL version() CALLS.
 * If you need to change the schema, increment CURRENT_SCHEMA_VERSION instead.
 */
class SteamSalesDB extends Dexie {
  sales!: EntityTable<SalesRecord, 'id'>;
  syncMeta!: EntityTable<SyncMeta, 'key'>;
  dailyAggregates!: EntityTable<DailyAggregate, 'date'>;
  appAggregates!: EntityTable<AppAggregate, 'appId'>;
  countryAggregates!: EntityTable<CountryAggregate, 'countryCode'>;
  aggregatesMeta!: EntityTable<AggregatesMeta, 'key'>;

  constructor() {
    super(DATABASE_NAME);

    // =========================================================================
    // SINGLE SCHEMA VERSION - DO NOT ADD MORE VERSIONS
    //
    // If you need to change the schema:
    // 1. Increment CURRENT_SCHEMA_VERSION at the top of this file
    // 2. The database name will change, causing a fresh start
    //
    // DO NOT add .version(2), .version(3), etc.
    // DO NOT add .upgrade() handlers
    // DO NOT try to migrate data between versions
    // =========================================================================
    this.version(1).stores({
      // Primary key 'id' is a string generated by generateUniqueKey()
      // This ensures records with the same identifying fields overwrite each other
      sales:
        'id, date, appId, packageId, countryCode, apiKeyId, [date+appId+packageId+countryCode+apiKeyId]',
      syncMeta: 'key',
      dailyAggregates: 'date',
      appAggregates: 'appId',
      countryAggregates: 'countryCode',
      aggregatesMeta: 'key',
    });
  }
}

export const db = new SteamSalesDB();

// ============================================================================
// Database Initialization & Validation
// ============================================================================

/** Progress callback for database operations */
export type DbProgressCallback = (message: string, progress: number) => void;

/**
 * Expected number of pipe-separated parts in a valid unique key.
 * See generateUniqueKey() in steam-transform.ts for the canonical format.
 *
 * A valid key has exactly 12 parts:
 * partnerid|date|lineItemType|platform|countryCode|currency|apiKeyId|packageid|bundleid|packageSaleType|appid|gameItemId
 */
const EXPECTED_KEY_PARTS = 12;

/**
 * Check if a record ID matches the current valid format.
 * Returns false if the ID is in an old/invalid format.
 */
function isValidKeyFormat(id: string | number | undefined): boolean {
  if (typeof id !== 'string') return false;

  const parts = id.split('|');

  // Must have exactly EXPECTED_KEY_PARTS parts
  if (parts.length !== EXPECTED_KEY_PARTS) return false;

  // Basic sanity checks on expected fields
  // Part 1 (index 1) should be a date in YYYY/MM/DD format
  const datePart = parts[1];
  if (!/^\d{4}\/\d{2}\/\d{2}$/.test(datePart)) return false;

  return true;
}

/**
 * Check if the database contains any records with old/invalid key formats.
 * Returns true if old data is detected and database should be wiped.
 */
async function hasOldFormatData(): Promise<boolean> {
  const sampleSize = 100;
  const samples = await db.sales.limit(sampleSize).toArray();

  if (samples.length === 0) return false;

  for (const record of samples) {
    if (!isValidKeyFormat(record.id)) {
      console.warn('Detected old format data:', {
        id: record.id,
        type: typeof record.id,
        parts: typeof record.id === 'string' ? record.id.split('|').length : 'N/A',
      });
      return true;
    }
  }

  return false;
}

/**
 * Delete all old database versions to clean up storage.
 * This removes any databases from previous schema versions.
 */
async function deleteOldDatabases(): Promise<void> {
  // Known old database names from previous versions
  const oldDatabaseNames = [
    'SteamSalesDB',
    'SteamSalesDB_v2',
    // Add any other old database names here if needed
  ];

  for (const name of oldDatabaseNames) {
    try {
      await Dexie.delete(name);
      console.log(`Deleted old database: ${name}`);
    } catch {
      // Ignore errors - database may not exist
    }
  }
}

/**
 * Initialize the database - should be called on app startup.
 *
 * This function:
 * 1. Deletes any old database versions
 * 2. Opens the current database
 * 3. Validates that all data is in the current format
 * 4. If old format data is detected, wipes the entire database
 *
 * NO MIGRATION LOGIC - just validation and optional wipe.
 */
export async function initializeDatabase(onProgress?: DbProgressCallback): Promise<{
  cleanedRecords: number;
  databaseWiped: boolean;
}> {
  onProgress?.('Opening database...', 0);

  // Step 1: Delete old database versions
  onProgress?.('Cleaning up old databases...', 5);
  await deleteOldDatabases();

  // Step 2: Open the current database
  onProgress?.('Opening database...', 10);
  try {
    await db.open();
  } catch (error) {
    console.error('Failed to open database:', error);
    // If we can't open, try to delete and recreate
    onProgress?.('Recreating database...', 15);
    db.close();
    await db.delete();
    await db.open();
  }

  // Step 3: Check for old format data
  onProgress?.('Validating data format...', 20);
  const hasOldData = await hasOldFormatData();

  if (hasOldData) {
    // Step 4: Wipe the database if old data detected
    console.warn('Old format data detected. Wiping database...');
    onProgress?.('Old data format detected - clearing database...', 30);

    const recordCount = await db.sales.count();
    await clearAllData();
    await clearAggregates();

    onProgress?.('Database cleared. Please refresh your data.', 100);

    return {
      cleanedRecords: recordCount,
      databaseWiped: true,
    };
  }

  // Step 5: Database is valid
  onProgress?.('Database ready', 100);

  return {
    cleanedRecords: 0,
    databaseWiped: false,
  };
}

// ============================================================================
// Basic Operations
// ============================================================================

export async function clearAllData(): Promise<void> {
  await db.sales.clear();
  await db.syncMeta.clear();
}

/**
 * Get the total count of sales records
 */
export async function getTotalCount(): Promise<number> {
  return db.sales.count();
}

// ============================================================================
// Paginated Queries
// ============================================================================

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

/**
 * Get paginated sales records with optional filters
 * Uses indexed queries for efficient pagination
 */
export async function getSalesPaginated(
  page: number = 1,
  pageSize: number = 1000,
  filters?: Filters
): Promise<PaginatedResult<SalesRecord>> {
  const offset = (page - 1) * pageSize;

  // Start with base collection
  let collection = db.sales.toCollection();

  // Apply indexed filters where possible
  if (filters?.appIds && filters.appIds.length === 1) {
    // Single app filter can use index
    collection = db.sales.where('appId').equals(filters.appIds[0]);
  } else if (filters?.startDate && filters?.endDate) {
    collection = db.sales.where('date').between(filters.startDate, filters.endDate, true, true);
  } else if (filters?.startDate) {
    collection = db.sales.where('date').aboveOrEqual(filters.startDate);
  } else if (filters?.endDate) {
    collection = db.sales.where('date').belowOrEqual(filters.endDate);
  }

  // Get total count for this filter (for pagination info)
  const total = await collection.count();

  // Get paginated results
  let results = await collection.offset(offset).limit(pageSize).toArray();

  // Apply non-indexed filters in memory
  if (filters) {
    if (filters.countryCode) {
      results = results.filter((r) => r.countryCode === filters.countryCode);
    }
    // App filter (multi-select)
    if (filters.appIds && filters.appIds.length > 1) {
      const appIdSet = new Set(filters.appIds);
      results = results.filter((r) => appIdSet.has(r.appId));
    }
    // API key filter (multi-select)
    if (filters.apiKeyIds && filters.apiKeyIds.length > 0) {
      const apiKeyIdSet = new Set(filters.apiKeyIds);
      results = results.filter((r) => apiKeyIdSet.has(r.apiKeyId));
    }
    // Date filters if not already applied via index
    if (filters.startDate && !(filters.appIds && filters.appIds.length === 1)) {
      results = results.filter((r) => r.date >= filters.startDate!);
    }
    if (filters.endDate && !(filters.appIds && filters.appIds.length === 1)) {
      results = results.filter((r) => r.date <= filters.endDate!);
    }
    if (filters.appIds && filters.appIds.length === 1 && (filters.startDate || filters.endDate)) {
      // If we filtered by single appId via index, still need to apply date filters
      if (filters.startDate) {
        results = results.filter((r) => r.date >= filters.startDate!);
      }
      if (filters.endDate) {
        results = results.filter((r) => r.date <= filters.endDate!);
      }
    }
  }

  return {
    data: results,
    total,
    page,
    pageSize,
    hasMore: offset + results.length < total,
  };
}

/**
 * Stream sales records in batches, calling callback for each batch
 * Useful for processing large datasets without loading all into memory
 */
export async function streamSalesInBatches(
  batchSize: number,
  callback: (
    batch: SalesRecord[],
    progress: { processed: number; total: number }
  ) => Promise<void> | void,
  filters?: Filters
): Promise<void> {
  const total = await getTotalCount();
  let processed = 0;
  let offset = 0;

  while (offset < total) {
    const result = await getSalesPaginated(Math.floor(offset / batchSize) + 1, batchSize, filters);

    if (result.data.length === 0) break;

    processed += result.data.length;
    await callback(result.data, { processed, total });

    offset += batchSize;

    // Yield to allow UI updates
    await new Promise((resolve) => setTimeout(resolve, 0));
  }
}

// ============================================================================
// Optimized Metadata Queries (using indexed queries where possible)
// ============================================================================

/**
 * Get unique apps - optimized to use cursor for streaming
 */
export async function getUniqueApps(): Promise<{ appId: number; appName: string }[]> {
  const uniqueApps = new Map<number, string>();

  // Use cursor to stream through data without loading all into memory
  await db.sales.orderBy('appId').eachUniqueKey(async (appId) => {
    if (typeof appId === 'number') {
      // Get one record to get the app name
      const record = await db.sales.where('appId').equals(appId).first();
      if (record) {
        uniqueApps.set(appId, record.appName || `App ${appId}`);
      }
    }
  });

  return Array.from(uniqueApps.entries()).map(([appId, appName]) => ({
    appId,
    appName,
  }));
}

/**
 * Get unique countries - optimized to use cursor
 */
export async function getUniqueCountries(): Promise<string[]> {
  const countries = new Set<string>();

  // Use cursor to stream through unique country codes
  await db.sales.orderBy('countryCode').eachUniqueKey((code) => {
    if (typeof code === 'string') {
      countries.add(code);
    }
  });

  return Array.from(countries).sort();
}

/**
 * Get date range - optimized to only fetch first and last records
 */
export async function getDateRange(): Promise<{ min: string; max: string } | null> {
  // Get first record by date (ascending)
  const first = await db.sales.orderBy('date').first();

  if (!first) {
    return null;
  }

  // Get last record by date (descending)
  const last = await db.sales.orderBy('date').last();

  return {
    min: first.date,
    max: last?.date || first.date,
  };
}

// ============================================================================
// Aggregation Queries (computed at DB level where possible)
// ============================================================================

/**
 * Get record count by app ID
 */
export async function getCountByApp(): Promise<Map<number, number>> {
  const counts = new Map<number, number>();

  await db.sales.orderBy('appId').eachUniqueKey(async (appId) => {
    if (typeof appId === 'number') {
      const count = await db.sales.where('appId').equals(appId).count();
      counts.set(appId, count);
    }
  });

  return counts;
}

/**
 * Get record count by date
 */
export async function getCountByDate(): Promise<Map<string, number>> {
  const counts = new Map<string, number>();

  await db.sales.orderBy('date').eachUniqueKey(async (date) => {
    if (typeof date === 'string') {
      const count = await db.sales.where('date').equals(date).count();
      counts.set(date, count);
    }
  });

  return counts;
}

/**
 * Get sales for a specific app ID (paginated)
 */
export async function getSalesForApp(
  appId: number,
  page: number = 1,
  pageSize: number = 1000
): Promise<PaginatedResult<SalesRecord>> {
  const offset = (page - 1) * pageSize;

  const collection = db.sales.where('appId').equals(appId);
  const total = await collection.count();
  const data = await collection.offset(offset).limit(pageSize).toArray();

  return {
    data,
    total,
    page,
    pageSize,
    hasMore: offset + data.length < total,
  };
}

/**
 * Get sales for a specific date range (paginated)
 */
export async function getSalesForDateRange(
  startDate: string,
  endDate: string,
  page: number = 1,
  pageSize: number = 1000
): Promise<PaginatedResult<SalesRecord>> {
  const offset = (page - 1) * pageSize;

  const collection = db.sales.where('date').between(startDate, endDate, true, true);
  const total = await collection.count();
  const data = await collection.offset(offset).limit(pageSize).toArray();

  return {
    data,
    total,
    page,
    pageSize,
    hasMore: offset + data.length < total,
  };
}

// ============================================================================
// Pre-computed Aggregates
// ============================================================================

/**
 * Check if aggregates need to be recomputed
 */
export async function aggregatesNeedUpdate(): Promise<boolean> {
  const meta = await db.aggregatesMeta.get('lastUpdated');
  if (!meta) return true;

  const totalRecordsMeta = await db.aggregatesMeta.get('totalRecords');
  const currentCount = await db.sales.count();

  if (!totalRecordsMeta || parseInt(totalRecordsMeta.value) !== currentCount) {
    return true;
  }

  return false;
}

/**
 * Compute and store all aggregates
 * Call this after data sync to pre-compute summaries
 */
export async function computeAndStoreAggregates(
  onProgress?: (message: string, progress: number) => void
): Promise<void> {
  const totalRecords = await db.sales.count();
  if (totalRecords === 0) {
    // Clear existing aggregates
    await db.dailyAggregates.clear();
    await db.appAggregates.clear();
    await db.countryAggregates.clear();
    await db.aggregatesMeta.clear();
    return;
  }

  onProgress?.('Computing daily aggregates...', 10);

  // Compute daily aggregates
  const dailyMap = new Map<string, DailyAggregate>();
  const appMap = new Map<number, AppAggregate>();
  const countryMap = new Map<string, CountryAggregate>();

  const BATCH_SIZE = 50000;

  // Stream through all sales in batches
  await streamSalesInBatches(BATCH_SIZE, async (batch, { processed, total }) => {
    for (const sale of batch) {
      // Daily aggregate
      const daily = dailyMap.get(sale.date) || {
        date: sale.date,
        totalRevenue: 0,
        totalUnits: 0,
        recordCount: 0,
      };
      daily.totalRevenue += sale.netSalesUsd ?? 0;
      daily.totalUnits += sale.unitsSold ?? 0;
      daily.recordCount++;
      dailyMap.set(sale.date, daily);

      // App aggregate
      const app = appMap.get(sale.appId) || {
        appId: sale.appId,
        appName: sale.appName || `App ${sale.appId}`,
        totalRevenue: 0,
        totalUnits: 0,
        recordCount: 0,
        firstSaleDate: sale.date,
        lastSaleDate: sale.date,
      };
      app.totalRevenue += sale.netSalesUsd ?? 0;
      app.totalUnits += sale.unitsSold ?? 0;
      app.recordCount++;
      if (sale.appName) app.appName = sale.appName;
      if (sale.date < app.firstSaleDate) app.firstSaleDate = sale.date;
      if (sale.date > app.lastSaleDate) app.lastSaleDate = sale.date;
      appMap.set(sale.appId, app);

      // Country aggregate
      const country = countryMap.get(sale.countryCode) || {
        countryCode: sale.countryCode,
        totalRevenue: 0,
        totalUnits: 0,
        recordCount: 0,
      };
      country.totalRevenue += sale.netSalesUsd ?? 0;
      country.totalUnits += sale.unitsSold ?? 0;
      country.recordCount++;
      countryMap.set(sale.countryCode, country);
    }

    const progress = Math.round((processed / total) * 70) + 10;
    onProgress?.(
      `Processing records... ${processed.toLocaleString()} / ${total.toLocaleString()}`,
      progress
    );
  });

  // Store aggregates in database
  onProgress?.('Storing daily aggregates...', 80);
  await db.dailyAggregates.clear();
  await db.dailyAggregates.bulkPut(Array.from(dailyMap.values()));

  onProgress?.('Storing app aggregates...', 85);
  await db.appAggregates.clear();
  await db.appAggregates.bulkPut(Array.from(appMap.values()));

  onProgress?.('Storing country aggregates...', 90);
  await db.countryAggregates.clear();
  await db.countryAggregates.bulkPut(Array.from(countryMap.values()));

  // Update metadata
  onProgress?.('Finalizing...', 95);
  await db.aggregatesMeta.bulkPut([
    { key: 'lastUpdated', value: new Date().toISOString() },
    { key: 'totalRecords', value: totalRecords.toString() },
  ]);

  onProgress?.('Complete!', 100);
}

/**
 * Get pre-computed daily aggregates
 * Falls back to computing on-the-fly if not available
 */
export async function getDailyAggregates(): Promise<DailyAggregate[]> {
  const aggregates = await db.dailyAggregates.orderBy('date').toArray();

  if (aggregates.length > 0) {
    return aggregates;
  }

  // Fall back to on-the-fly computation for small datasets
  const count = await db.sales.count();
  if (count === 0) return [];

  // For larger datasets, trigger background computation
  if (count > 10000) {
    console.warn('Daily aggregates not pre-computed. Consider calling computeAndStoreAggregates()');
  }

  return aggregates;
}

/**
 * Get pre-computed app aggregates
 */
export async function getAppAggregates(): Promise<AppAggregate[]> {
  const aggregates = await db.appAggregates.toArray();
  return aggregates.sort((a, b) => b.totalRevenue - a.totalRevenue);
}

/**
 * Get pre-computed country aggregates
 */
export async function getCountryAggregates(): Promise<CountryAggregate[]> {
  const aggregates = await db.countryAggregates.toArray();
  return aggregates.sort((a, b) => b.totalRevenue - a.totalRevenue);
}

/**
 * Get aggregate statistics
 */
export async function getAggregateStats(): Promise<{
  totalRevenue: number;
  totalUnits: number;
  totalRecords: number;
  uniqueApps: number;
  uniqueCountries: number;
  dateRange: { min: string; max: string } | null;
}> {
  const [appAggregates, countryAggregates, dailyAggregates] = await Promise.all([
    db.appAggregates.toArray(),
    db.countryAggregates.toArray(),
    db.dailyAggregates.orderBy('date').toArray(),
  ]);

  const totalRevenue = appAggregates.reduce((sum, a) => sum + a.totalRevenue, 0);
  const totalUnits = appAggregates.reduce((sum, a) => sum + a.totalUnits, 0);
  const totalRecords = appAggregates.reduce((sum, a) => sum + a.recordCount, 0);

  return {
    totalRevenue,
    totalUnits,
    totalRecords,
    uniqueApps: appAggregates.length,
    uniqueCountries: countryAggregates.length,
    dateRange:
      dailyAggregates.length > 0
        ? { min: dailyAggregates[0].date, max: dailyAggregates[dailyAggregates.length - 1].date }
        : null,
  };
}

/**
 * Clear all aggregates (call when data is wiped)
 */
export async function clearAggregates(): Promise<void> {
  await db.dailyAggregates.clear();
  await db.appAggregates.clear();
  await db.countryAggregates.clear();
  await db.aggregatesMeta.clear();
}
